<script>
    const contractAddress = "0xf6b491763ca2e099bb6c9d3e573524c426152aeb";
    const USDC = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";

    const contractABI = [
      { "inputs": [{ "internalType": "address", "name": "usdcAddress", "type": "address" }], "name": "initialize", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [
          { "internalType": "uint256", "name": "amount", "type": "uint256" },
          { "internalType": "address", "name": "payer", "type": "address" },
          { "internalType": "address[]", "name": "participants", "type": "address[]" },
          { "internalType": "string", "name": "category", "type": "string" }
        ], "name": "addExpense", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [{ "internalType": "address", "name": "creditor", "type": "address" }, { "internalType": "string", "name": "category", "type": "string" }], "name": "settle", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [
          { "internalType": "address", "name": "debtor", "type": "address" },
          { "internalType": "uint256", "name": "newAmount", "type": "uint256" },
          { "internalType": "string", "name": "category", "type": "string" }
        ], "name": "adjustBalance", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [
          { "internalType": "address", "name": "debtor", "type": "address" },
          { "internalType": "address", "name": "creditor", "type": "address" },
          { "internalType": "string", "name": "category", "type": "string" }
        ], "name": "getBalance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }
    ];

    let provider, signer, contract, account, usdcContract;
    let contacts = {};

    function shortAddr(addr) { return addr.slice(0,6) + '...' + addr.slice(-4); }
    
    function toast(msg) {¬†
      const el = document.createElement('div');¬†
      el.className = 'toast';¬†
      el.textContent = msg;¬†
      document.body.appendChild(el);¬†
      setTimeout(() => el.remove(), 3000);¬†
    }
    
    function loadContacts() {
      const stored = localStorage.getItem("settleup-contacts");
      if (stored) {
        try {
          contacts = JSON.parse(stored);
        } catch(e) {
          console.error("Failed to load contacts", e);
          contacts = {};
        }
      }
    }
    
    function saveContacts() {
      localStorage.setItem("settleup-contacts", JSON.stringify(contacts));
    }
    
    function addContact(address, name) {
      const addr = address.toLowerCase();
      if (!name || name.trim() === "") return toast("‚ö†Ô∏è Name required");
      contacts[addr] = name.trim();
      saveContacts();
      renderContacts();
      toast(`‚úÖ Added ${name}`);
    }
    
    function deleteContact(address) {
      const addr = address.toLowerCase();
      if (addr === account.toLowerCase()) {
        return toast("‚ùå Can't delete yourself");
      }
      delete contacts[addr];
      saveContacts();
      renderContacts();
      toast("‚úÖ Deleted");
    }
    
    function renderContacts() {
      const list = document.getElementById("contactsList");
      list.innerHTML = "";
      
      if (!account) return;
      
      const youBtn = document.createElement("button");
      youBtn.className = "contact-btn you";
      youBtn.textContent = "üìç You";
      youBtn.style.pointerEvents = "auto";
      youBtn.onclick = (e) => {
        e.preventDefault();
        document.getElementById("payer").value = account;
        toast(`‚úÖ Payer: You`);
      };
      list.appendChild(youBtn);
      
      Object.entries(contacts).forEach(([addr, name]) => {
        if (addr === account.toLowerCase()) return;
        
        const btn = document.createElement("button");
        btn.className = "contact-btn";
        btn.style.position = "relative";
        
        const deleteIcon = document.createElement("div");
        deleteIcon.className = "delete-icon";
        deleteIcon.textContent = "‚úï";
        deleteIcon.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (confirm(`Delete ${name}?`)) {
            deleteContact(addr);
          }
        };
        
        btn.textContent = name;
        btn.appendChild(deleteIcon);
        
        btn.onclick = (e) => {
          e.preventDefault();
          const participants = document.getElementById("participants").value.trim();
          const arr = participants ? participants.split(",").map(x => x.trim()) : [];
          
          if (!arr.map(x => x.toLowerCase()).includes(addr)) {
            arr.push(addr);
            document.getElementById("participants").value = arr.join(", ");
            toast(`‚úÖ Added ${name}`);
          } else {
            toast("‚ö†Ô∏è Already added");
          }
        };
        
        list.appendChild(btn);
      });
    }

    async function connectWallet() {
      if (!window.ethereum) return toast("‚ö†Ô∏è Please install MetaMask!");
      
      const btn = document.getElementById("connectWallet");
      btn.disabled = true;
      
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        account = await signer.getAddress();
        contract = new ethers.Contract(contractAddress, contractABI, signer);

        const net = await provider.getNetwork();
        if (net.chainId !== 8453) {
          toast("‚ö†Ô∏è Switching to Base Mainnet...");
          try {
            await window.ethereum.request({¬†
              method: 'wallet_switchEthereumChain',¬†
              params: [{ chainId: '0x2105' }]¬†
            });
            location.reload();
            return;
          } catch (e) {
            toast("‚ùå Please switch to Base Mainnet manually");
            btn.disabled = false;
            return;
          }
        }

        loadContacts();
        
        if (!contacts[account.toLowerCase()]) {
          const userName = prompt("What's your name?", "Me");
          if (userName) {
            addContact(account, userName);
          }
        }

        document.getElementById("walletAddress").textContent = shortAddr(account);
        document.getElementById("payer").value = account;
        document.getElementById("walletStatus").style.display = "block";
        document.getElementById("addExpenseCard").style.display = "block";
        document.getElementById("adjustCard").style.display = "block";
        document.getElementById("balancesCard").style.display = "block";
        btn.style.display = "none";

        renderContacts();
        await initUSDC();
        await refreshBalances();

        window.ethereum.on('accountsChanged', () => location.reload());
        window.ethereum.on('chainChanged', () => location.reload());
        
        toast("‚úÖ Connected successfully!");
      } catch (e) {¬†
        toast("‚ùå Connection failed");
        console.error(e);
      } finally {¬†
        btn.disabled = false;¬†
      }
    }

    async function initUSDC() {
      usdcContract = new ethers.Contract(USDC, [
        "function balanceOf(address) view returns (uint256)",
        "function allowance(address,address) view returns (uint256)",
        "function approve(address,uint256) returns (bool)"
      ], signer);
      
      const bal = await usdcContract.balanceOf(account);
      document.getElementById("usdcBalance").textContent = `üíµ ${ethers.utils.formatUnits(bal, 6)} USDC`;
      
      const allowance = await usdcContract.allowance(account, contractAddress);
      if (allowance.lt(ethers.utils.parseUnits("1000", 6))) {
        document.getElementById("approveUSDC").style.display = "block";
      }
    }

    document.getElementById("approveUSDC").onclick = async () => {
      const btn = document.getElementById("approveUSDC");
      btn.disabled = true;
      
      try {
        const tx = await usdcContract.approve(contractAddress, ethers.constants.MaxUint256);
        toast("‚è≥ Approving USDC...");
        await tx.wait();
        btn.style.display = "none";
        toast("‚úÖ USDC approved!");
        await initUSDC();
      } catch (e) {¬†
        toast("‚ùå Approval failed");
        console.error(e);
      } finally {¬†
        btn.disabled = false;¬†
      }
    };

    document.getElementById("addContactBtn").onclick = () => {
      const addr = prompt("Address (0x...):");
      if (!addr) return;
      
      if (!ethers.utils.isAddress(addr)) {
        return toast("‚ùå Invalid address");
      }
      
      const name = prompt("Name for this contact:");
      if (name) {
        addContact(addr, name);
      }
    };

    async function addExpense() {
      const amountInput = document.getElementById("amount").value.trim();
      const payer = document.getElementById("payer").value.trim();
      const participantsInput = document.getElementById("participants").value.trim();
      const desc = document.getElementById("expenseDesc").value.trim() || "Expense";
      const statusEl = document.getElementById("addExpenseStatus");

      if (!amountInput || !payer || !participantsInput) {
        return toast("‚ö†Ô∏è Please fill all required fields");
      }
      
      if (!ethers.utils.isAddress(payer)) {
        return toast("‚ö†Ô∏è Invalid payer address");
      }

      const amountFloat = parseFloat(amountInput);
      if (isNaN(amountFloat) || amountFloat <= 0) {
        return toast("‚ö†Ô∏è Invalid amount");
      }

      const amount = ethers.utils.parseUnits(amountInput, 6);

      const participants = [...new Set(
        participantsInput
          .split(",")
          .map(a => a.trim())
          .filter(a => ethers.utils.isAddress(a) && a.toLowerCase() !== payer.toLowerCase())
      )];

      if (participants.length === 0) {
        return toast("‚ö†Ô∏è Add at least one participant");
      }

      const btn = document.getElementById("addExpense");
      btn.disabled = true;
      statusEl.textContent = "";
      statusEl.className = "";

      try {
        const tx = await contract.addExpense(amount, payer, participants, desc);
        
        statusEl.textContent = "‚è≥ Confirming transaction...";
        statusEl.className = "status-message success";

        const receipt = await tx.wait();

        statusEl.innerHTML = `‚úÖ Expense recorded! <a href="https://basescan.org/tx/${receipt.transactionHash}" target="_blank">View Tx</a>`;
        statusEl.className = "status-message success";

        document.getElementById("amount").value = "";
        document.getElementById("participants").value = "";
        document.getElementById("expenseDesc").value = "";

        toast(`‚úÖ "${desc}" recorded!`);
        
        await refreshBalances(); // FIXED: Direct call to refresh balances
      } catch (e) {
        statusEl.textContent = "‚ùå Failed: " + (e.reason || e.message);
        statusEl.className = "status-message error";
        toast("‚ùå Transaction failed");
      } finally {
        btn.disabled = false;
      }
    }

    async function adjustBalanceSubmit() {
      const debtorInput = document.getElementById("adjustDebtor").value.trim();
      const amountInput = document.getElementById("adjustAmount").value.trim();
      const statusEl = document.getElementById("adjustStatus");

      if (!debtorInput || amountInput === "") {
        return toast("‚ö†Ô∏è Please fill all fields");
      }

      if (!ethers.utils.isAddress(debtorInput)) {
        return toast("‚ö†Ô∏è Invalid debtor address");
      }

      const amountFloat = parseFloat(amountInput);
      if (isNaN(amountFloat) || amountFloat < 0) {
        return toast("‚ö†Ô∏è Invalid amount");
      }

      const newAmount = ethers.utils.parseUnits(amountInput, 6);
      const btn = document.getElementById("adjustBalance");
      btn.disabled = true;
      statusEl.textContent = "";
      statusEl.className = "";

      try {
        const tx = await contract.adjustBalance(debtorInput, newAmount, "Expense");
        
        statusEl.textContent = "‚è≥ Updating balance...";
        statusEl.className = "status-message success";

        const receipt = await tx.wait();

        statusEl.innerHTML = `‚úÖ Balance updated! <a href="https://basescan.org/tx/${receipt.transactionHash}" target="_blank">View Tx</a>`;
        statusEl.className = "status-message success";

        document.getElementById("adjustDebtor").value = "";
        document.getElementById("adjustAmount").value = "";

        toast("‚úÖ Balance adjusted!");
        await refreshBalances(); // FIXED: Direct call to refresh balances
      } catch (e) {
        statusEl.textContent = "‚ùå Failed: " + (e.reason || e.message);
        statusEl.className = "status-message error";
        toast("‚ùå Adjustment failed");
      } finally {
        btn.disabled = false;
      }
    }

    async function settleWith(creditor) {
      const name = contacts[creditor.toLowerCase()] || shortAddr(creditor);
      if (!confirm(`Settle with ${name}?`)) return;
      
      try {
        const tx = await contract.settle(creditor, "Expense");
        toast("‚è≥ Settling...");
        await tx.wait();
        toast("‚úÖ Settled successfully!");
        
        await initUSDC();      // FIXED: Updates USDC wallet balance
        await refreshBalances(); // FIXED: Updates SettleUp balances
        
      } catch (e) {¬†
        toast("‚ùå Settlement failed");
        console.error(e);
      }
    }

    async function refreshBalances() {
      const el = document.getElementById("balances");
      const btn = document.getElementById("refreshBalances");

      if (!contract || !account) {
        el.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìä</div>
            <p>Connect wallet to view balances</p>
          </div>
        `;
        return;
      }

      btn.disabled = true;
      el.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">‚è≥</div>
          <p>Loading balances...</p>
        </div>
      `;

      try {
        const balancesMap = {};
        const category = "Expense"; // Make sure this matches what you used when adding expenses
        
        const contactAddrs = Object.keys(contacts);
        
        if (contactAddrs.length === 0) {
          el.innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">‚ÑπÔ∏è</div>
              <p>Add contacts to view balances</p>
            </div>
          `;
          btn.disabled = false;
          return;
        }
        
        for (const contactAddr of contactAddrs) {
          if (contactAddr.toLowerCase() === account.toLowerCase()) continue;
          
          try {
            // Query balances - try both directions with the same category
            const debtToUs = await contract.getBalance(contactAddr, account, category);
            const debtToThem = await contract.getBalance(account, contactAddr, category);
            
            console.log(`Balance for ${contactAddr}: We owe them: ${debtToThem.toString()}, They owe us: ${debtToUs.toString()}`);
            
            if (!debtToUs.isZero() || !debtToThem.isZero()) {
              balancesMap[contactAddr] = {
                debtToUs: debtToUs,
                debtToThem: debtToThem
              };
            }
          } catch (e) {
            console.warn(`Could not get balance for ${contactAddr} in category "${category}":`, e.message);
          }
        }

        const entries = Object.entries(balancesMap);
        
        if (entries.length === 0) {
          el.innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">‚ú®</div>
              <p>No active balances</p>
            </div>
          `;
          btn.disabled = false;
          return;
        }

        let html = '';

        for (const [addr, data] of entries) {
          const contactName = contacts[addr] || shortAddr(addr);
          
          if (!data.debtToUs.isZero()) {
            const val = parseFloat(ethers.utils.formatUnits(data.debtToUs, 6)).toFixed(2);
            html += `
              <div class="balance-item">
                <div class="balance-info">
                  <div class="balance-amount positive">
                    + ${val}
                  </div>
                  <div class="balance-name">${contactName} owes you</div>
                  <div style="font-size: 12px; color: #9ca3af; margin-top: 4px;">Expense</div>
                </div>
              </div>
            `;
          }
          
          if (!data.debtToThem.isZero()) {
            const val = parseFloat(ethers.utils.formatUnits(data.debtToThem, 6)).toFixed(2);
            html += `
              <div class="balance-item">
                <div class="balance-info">
                  <div class="balance-amount negative">
                    - ${val}
                  </div>
                  <div class="balance-name">You owe ${contactName}</div>
                  <div style="font-size: 12px; color: #9ca3af; margin-top: 4px;">Expense</div>
                </div>
                <button class="btn-settle" onclick="settleWith('${addr}')">Settle</button>
              </div>
            `;
          }
        }

        el.innerHTML = html;
        btn.disabled = false;
      } catch (e) {
        console.error("Error refreshing balances:", e);
        el.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">‚ö†Ô∏è</div>
            <p>Failed to load balances</p>
          </div>
        `;
        btn.disabled = false;
      }
    }

    document.getElementById("connectWallet").onclick = connectWallet;
    document.getElementById("addExpense").onclick = addExpense;
    document.getElementById("adjustBalance").onclick = adjustBalanceSubmit;
    document.getElementById("refreshBalances").onclick = refreshBalances;
  </script>
