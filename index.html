<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SettleUp - Split Bills in USDC</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; background: #f8fafc; color: #111827; padding: 20px; margin: 0; }
    h1 { color: #2563eb; text-align: center; margin-bottom: 30px; }
    .card { background: white; border-radius: 16px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 24px; margin: 20px auto; max-width: 600px; }
    input, button { display: block; width: 100%; margin: 12px 0; padding: 12px; border-radius: 8px; border: 1px solid #d1d5db; font-size: 16px; }
    button { background: #2563eb; color: white; cursor: pointer; border: none; font-weight: bold; }
    button:hover { background: #1d4ed8; }
    button:disabled { background: #94a3b8; cursor: not-allowed; }
    .success { color: #16a34a; font-weight: bold; }
    .error { color: #dc2626; }
    .balance-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #e2e8f0; }
    .balance-item:last-child { border-bottom: none; }
    .settle-btn { background: #10b981; color: white; padding: 6px 12px; font-size: 14px; border-radius: 6px; border: none; cursor: pointer; }
    .settle-btn:hover { background: #059669; }
    .loading { opacity: 0.6; pointer-events: none; }
    .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #2563eb; color: white; padding: 12px 24px; border-radius: 8px; font-size: 14px; animation: fade 3s forwards; z-index: 1000; }
    .tag { font-size: 12px; color: #6b7280; font-style: italic; margin-left: 6px; }
    @keyframes fade { 0%, 70% { opacity: 1; } 100% { opacity: 0; } }
  </style>
</head>
<body>
  <h1>SettleUp - Split Bills in USDC</h1>

  <div class="card">
    <button id="connectWallet">Connect Wallet</button>
    <p id="walletAddress" class="success"></p>
    <p id="usdcBalance"></p>
    <button id="approveUSDC" style="display:none; margin:10px 0;">Approve USDC for SettleUp</button>

    <h3>Add Expense</h3>
    <input type="tel" inputmode="decimal" step="0.01" id="amount" placeholder="Amount in USDC (e.g. 30.00)" />
    <input type="text" id="participants" placeholder="Participants (e.g. bob.base.eth, 0x123..., charlie.eth)" />
    <label for="payer">Payer (who paid with card)</label>
    <input type="text" id="payer" placeholder="e.g. alstarian.base.eth or 0x..." />
    
    <label for="expenseDesc">Expense Description (optional)</label>
    <input type="text" id="expenseDesc" placeholder="e.g. Lunch at Chipotle, Cinema - Avengers" />

    <button id="addExpense" disabled>Record Expense</button>
    <p id="addExpenseStatus"></p>
  </div>

  <div class="card">
    <h3>Your Balances</h3>
    <button id="refreshBalances" disabled>Refresh Balances</button>
    <div id="balances">Connect wallet first...</div>
  </div>

  <script>
    const contractAddress = "0xe96cE1AcEF0DCe364a9e7e751D46e1B6Da0cce40";
    const USDC = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";

    const contractABI = [
      { "inputs": [{ "internalType": "address", "name": "usdcAddress", "type": "address" }], "stateMutability": "nonpayable", "type": "constructor" },
      { "anonymous": false, "inputs": [
          { "indexed": true, "internalType": "address", "name": "payer", "type": "address" },
          { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" },
          { "indexed": false, "internalType": "address[]", "name": "participants", "type": "address[]" }
        ], "name": "ExpenseAdded", "type": "event" },
      { "anonymous": false, "inputs": [
          { "indexed": true, "internalType": "address", "name": "debtor", "type": "address" },
          { "indexed": true, "internalType": "address", "name": "creditor", "type": "address" },
          { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
        ], "name": "Settled", "type": "event" },
      { "inputs": [
          { "internalType": "uint256", "name": "amount", "type": "uint256" },
          { "internalType": "address", "name": "payer", "type": "address" },
          { "internalType": "address[]", "name": "participants", "type": "address[]" }
        ], "name": "addExpense", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [{ "internalType": "address", "name": "creditor", "type": "address" }], "name": "settle", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [], "name": "getMyBalances", "outputs": [
          { "internalType": "address[]", "name": "creditors", "type": "address[]" },
          { "internalType": "int256[]", "name": "amounts", "type": "int256[]" }
        ], "stateMutability": "view", "type": "function" }
    ];

    let provider, signer, contract, account, usdcContract;

    function shortAddr(addr) { return addr.slice(0,6) + '...' + addr.slice(-4); }
    function setLoading(el, loading) { loading ? el.classList.add('loading') || (el.disabled = true) : el.classList.remove('loading') || (el.disabled = false); }
    function toast(msg) { const el = document.createElement('div'); el.className = 'toast'; el.textContent = msg; document.body.appendChild(el); setTimeout(() => el.remove(), 3000); }

    // RESOLVE ENS NAMES
    async function resolveName(name) {
      if (ethers.utils.isAddress(name)) return name;
      if (!name.includes('.')) return null;
      try {
        const addr = await provider.resolveName(name.trim());
        if (addr && ethers.utils.isAddress(addr)) return addr;
      } catch (e) {
        console.warn("ENS resolve failed:", name, e);
      }
      return null;
    }

    async function connectWallet() {
      if (!window.ethereum) return toast("Install MetaMask!");
      const btn = document.getElementById("connectWallet");
      setLoading(btn, true);
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        account = await signer.getAddress();
        contract = new ethers.Contract(contractAddress, contractABI, signer);

        const net = await provider.getNetwork();
        if (net.chainId !== 8453) {
          toast("Switch to Base Mainnet");
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x2105' }] });
          setLoading(btn, false);
          return;
        }

        const ensName = await provider.lookupAddress(account) || shortAddr(account);
        document.getElementById("walletAddress").textContent = `Connected: ${ensName}`;
        document.getElementById("payer").value = ensName.includes('.') ? ensName : account;

        document.getElementById("addExpense").disabled = false;
        document.getElementById("refreshBalances").disabled = false;

        await initUSDC();
        refreshBalances();

        window.ethereum.on('accountsChanged', () => location.reload());
        window.ethereum.on('chainChanged', () => location.reload());
      } catch (e) { toast("Connect failed: " + (e.reason || e.message)); } finally { setLoading(btn, false); }
    }

    async function initUSDC() {
      usdcContract = new ethers.Contract(USDC, [
        "function balanceOf(address) view returns (uint256)",
        "function allowance(address,address) view returns (uint256)",
        "function approve(address,uint256) returns (bool)"
      ], signer);
      const bal = await usdcContract.balanceOf(account);
      document.getElementById("usdcBalance").textContent = `USDC: ${ethers.utils.formatUnits(bal, 6)}`;
      const allowance = await usdcContract.allowance(account, contractAddress);
      if (allowance.lt(ethers.utils.parseUnits("1000", 6))) document.getElementById("approveUSDC").style.display = "block";
    }

    document.getElementById("approveUSDC").onclick = async () => {
      const btn = document.getElementById("approveUSDC"); setLoading(btn, true);
      try {
        const tx = await usdcContract.approve(contractAddress, ethers.constants.MaxUint256);
        toast("Approving USDC…");
        await tx.wait();
        btn.style.display = "none";
        toast("USDC approved!");
      } catch (e) { toast("Approval failed: " + (e.reason || e.message)); } finally { setLoading(btn, false); }
    };

    async function addExpense() {
      const amountInput = document.getElementById("amount").value.trim();
      const payerInput = document.getElementById("payer").value.trim();
      const participantsInput = document.getElementById("participants").value.trim();
      const desc = document.getElementById("expenseDesc").value.trim() || "Expense";
      const status = document.getElementById("addExpenseStatus");

      if (!amountInput || !payerInput || !participantsInput) return toast("Fill all fields");

      // Resolve ENS names
      const payerAddr = await resolveName(payerInput);
      if (!payerAddr) return toast("Invalid payer: not a valid address or ENS name");

      const participantNames = participantsInput.split(',').map(s => s.trim()).filter(Boolean);
      const participants = [];
      for (const name of participantNames) {
        const addr = await resolveName(name);
        if (!addr) return toast(`Invalid participant: ${name}`);
        if (addr.toLowerCase() === payerAddr.toLowerCase()) continue;
        participants.push(addr);
      }

      if (participants.length === 0) return toast("Add at least one other participant");

      const amount = ethers.utils.parseUnits(amountInput, 6);
      const btn = document.getElementById("addExpense");
      setLoading(btn, true);
      status.textContent = "";
      status.className = "";

      try {
        const tx = await contract.addExpense(amount, payerAddr, participants);
        status.textContent = "Confirming…";
        status.className = "success";
        await tx.wait();

        status.innerHTML = `Recorded! <a href="https://basescan.org/tx/${tx.hash}" target="_blank">View Tx</a>`;
        status.className = "success";

        document.getElementById("amount").value = "";
        document.getElementById("participants").value = "";
        document.getElementById("expenseDesc").value = "";

        window.lastExpenseDesc = desc;
        toast(`Expense recorded: "${desc}"!`);
        setTimeout(refreshBalances, 1500);
      } catch (e) {
        status.textContent = "Failed: " + (e.reason || e.message);
        status.className = "error";
      } finally {
        setLoading(btn, false);
      }
    }

    async function settleWith(creditor) {
      if (!confirm(`Settle with ${shortAddr(creditor)}?`)) return;
      try {
        const tx = await contract.settle(creditor);
        toast("Settling…");
        await tx.wait();
        toast(`Settled! https://basescan.org/tx/${tx.hash}`);
        refreshBalances();
      } catch (e) { toast("Settle error: " + (e.reason || e.message)); }
    }

    async function refreshBalances() {
      const el = document.getElementById("balances");
      const btn = document.getElementById("refreshBalances");

      if (!contract || !account) { el.innerHTML = "Connect wallet first…"; return; }

      setLoading(btn, true);
      el.innerHTML = "Loading…";

      let creditors = [], amounts = [];
      try {
        [creditors, amounts] = await contract.getMyBalances();
      } catch (e) {
        console.warn("getMyBalances failed", e);
        el.innerHTML = `<span class="error">Loading balances... (this may take a few seconds)</span>`;
        setLoading(btn, false);
        return;
      }

      if (!creditors || creditors.length === 0) {
        el.innerHTML = "<em>No balances.</em>";
        setLoading(btn, false);
        return;
      }

      let html = "";
      const desc = window.lastExpenseDesc || "Expense";

      for (let i = 0; i < creditors.length; i++) {
        const addr = creditors[i];
        if (addr.toLowerCase() === account.toLowerCase()) continue;

        const raw = amounts[i].toString();
        const positive = !raw.startsWith("-");
        const absRaw = positive ? raw : raw.slice(1);
        const absBN = ethers.BigNumber.from(absRaw);
        const val = parseFloat(ethers.utils.formatUnits(absBN, 6)).toFixed(2);

        if (absBN.isZero()) continue;

        const name = (await provider.lookupAddress(addr)) || shortAddr(addr);
        const tag = `<span class="tag">(${desc})</span>`;

        if (positive) {
          html += `<div class="balance-item">
                     <span style="color:#16a34a;">$${val} owed to you by</span> ${name} ${tag}
                   </div>`;
        } else {
          html += `<div class="balance-item">
                     <span style="color:#dc2626;">You owe $${val} to</span> ${name} ${tag}
                     <button class="settle-btn" onclick="settleWith('${addr}')">Settle</button>
                   </div>`;
        }
      }

      el.innerHTML = html || "<em>No balances.</em>";
      setLoading(btn, false);
    }

    document.getElementById("connectWallet").onclick = connectWallet;
    document.getElementById("addExpense").onclick = addExpense;
    document.getElementById("refreshBalances").onclick = refreshBalances;
  </script>
</body>
</html>
